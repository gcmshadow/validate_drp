__all__ = ["MatchedVisitMetricsRunner", "MatchedVisitMetricsConfig", "MatchedVisitMetricsTask"]

import os
import sys
import traceback
import lsst.pipe.base as pipeBase
from lsst.pipe.base import CmdLineTask, ArgumentParser, TaskRunner
from lsst.pex.config import Config, Field, ChoiceField
from lsst.meas.base.forcedPhotCcd import PerTractCcdDataIdContainer
from .validate import runOneFilter, plot_metrics


class MatchedVisitMetricsRunner(TaskRunner):
    """Subclass of TaskRunner for MatchedVisitMetrics

    This class transforms the processed
    arguments generated by the ArgumentParser into the arguments expected by
    MatchedVisitMetricsTask.run().
    """

    @staticmethod
    def getTargetList(parsedCmd, **kwargs):
        # organize data IDs by filter
        id_list_dict = {}
        for ref in parsedCmd.id.refList:
            id_list_dict.setdefault(ref.dataId["filter"], []).append(ref.dataId)
        # we call run() once with each filter
        return [(parsedCmd.butler,
                 filterName,
                 parsedCmd.output,
                 id_list_dict[filterName],
                 ) for filterName in sorted(id_list_dict.keys())]

    def __call__(self, args):
        exitStatus = 0

        task = self.TaskClass(config=self.config, log=self.log)

        try:
            task.run(*args)
        except Exception as e:
            exitStatus = 1
            task.log.fatal("Failed: %s" % e)
            if not isinstance(e, pipeBase.TaskError):
                traceback.print_exc(file=sys.stderr)

        return pipeBase.Struct(exitStatus=exitStatus)


class MatchedVisitMetricsConfig(Config):
    instrumentName = Field(
        dtype=str, optional=False,
        doc="Instrument name to associate with verification specifications: e.g. HSC, CFHT, DECAM"
    )
    datasetName = Field(
        dtype=str, optional=False,
        doc="Dataset name to associate metric measuremnts in SQuaSH"
    )
    outputPrefix = Field(
        dtype=str, default="matchedVisit",
        doc="Root name for output files: the filter name is appended to this+'_'."
    )
    metricsRepository = Field(
        dtype=str, default='verify_metrics',
        doc="Repository to read metrics and specs from."
    )
    brightSnrMin = Field(
        dtype=float, default=None, optional=True,
        doc="Minimum PSF signal-to-noise ratio for a source to be considered bright."
    )
    brightSnrMax = Field(
        dtype=float, default=None, optional=True,
        doc="Maximum PSF signal-to-noise ratio for a source to be considered bright."
    )
    makeJson = Field(
        dtype=bool, default=True,
        doc="Whether to write JSON outputs."
    )
    makePlots = Field(
        dtype=bool, default=True,
        doc="Whether to write plot outputs."
    )
    matchRadius = Field(
        dtype=float, default=1.0,
        doc="Match radius (arcseconds)."
    )
    doApplyExternalPhotoCalib = Field(
        dtype=bool, default=False,
        doc=("Whether to apply external photometric calibration via an "
             "`lsst.afw.image.PhotoCalib` object.  Uses the "
             "`externalPhotoCalibName` field to determine which calibration "
             "to load.")
    )
    externalPhotoCalibName = ChoiceField(
        dtype=str,
        doc="Type of external PhotoCalib if `doApplyExternalPhotoCalib` is True.",
        default="jointcal",
        allowed={
            "jointcal": "Use jointcal_photoCalib",
            "fgcm": "Use fgcm_photoCalib",
            "fgcm_tract": "Use fgcm_tract_photoCalib"
        }
    )
    doApplyExternalSkyWcs = Field(
        dtype=bool, default=False,
        doc=("Whether to apply external astrometric calibration via an "
             "`lsst.afw.geom.SkyWcs` object.  Uses the `externalSkyWcsName` "
             "field to determine which calibration to load.")
    )
    externalSkyWcsName = ChoiceField(
        dtype=str,
        doc="Type of external SkyWcs if `doApplyExternalSkyWcs` is True.",
        default="jointcal",
        allowed={
            "jointcal": "Use jointcal_wcs"
        }
    )
    skipTEx = Field(
        dtype=bool, default=False,
        doc="Skip TEx calculations (useful for older catalogs that don't have PsfShape measurements)."
    )
    verbose = Field(
        dtype=bool, default=False,
        doc="More verbose output during validate calculations."
    )


class MatchedVisitMetricsTask(CmdLineTask):
    """An alternate command-line driver for the validate_drp metrics.

    MatchedVisitMetricsTask is very much an incomplete CmdLineTask - it uses
    the usual mechanisms to define its inputs and read them using a Butler,
    but writes outputs manually to files with a configuration-defined prefix
    (config.outputPrefix).  Because the CmdLineTask machinery always creates an
    output Butler repository, however, it is necessary to run this task with
    both an output directory and an output prefix, with the former essentially
    unused.

    The input data IDs passed via the `--id` argument should contain the same
    keys as the `wcs` dataset (those used by the `calexp` dataset plus
    `tract`).  When `config.doApplyExternalPhotoCalib` is `True`, the
    photometric calibration (`photoCalib`) is taken from
    `config.externalPhotoCalibName` via the `name_photoCalib` dataset.  Otherwise,
    the photometric calibration is retrieved from the `calexp`. When
    `config.doApplyExternalSkyWcs` is `True`, the astrometric calibration is taken
    from `config.externalSkyWcsName` with the `name_wcs` dataset.  Otherwise, the
    astrometric calbration is unchanged from the positions loaded from the
    `src` dataset.  In all cases the `tract` must be present.
    """

    _DefaultName = "matchedVisitMetrics"
    ConfigClass = MatchedVisitMetricsConfig
    RunnerClass = MatchedVisitMetricsRunner

    def run(self, butler, filterName, output, dataIds):
        """
        Compute cross-visit metrics for one filter.

        Parameters
        ----------
        butler      The initialized butler.
        filterName  The filter name to be processed.
        output      The output repository to save files to.
        dataIds     The butler dataIds to process.
        """
        output_prefix = os.path.join(output, "%s_%s"%(self.config.outputPrefix, filterName))
        # Metrics are no longer passed. The argument will go away with DM-14274
        job = runOneFilter(butler, dataIds, metrics=None,
                           brightSnrMin=self.config.brightSnrMin,
                           brightSnrMax=self.config.brightSnrMax,
                           makeJson=self.config.makeJson,
                           filterName=filterName,
                           outputPrefix=output_prefix,
                           doApplyExternalPhotoCalib=self.config.doApplyExternalPhotoCalib,
                           externalPhotoCalibName=self.config.externalPhotoCalibName,
                           doApplyExternalSkyWcs=self.config.doApplyExternalSkyWcs,
                           externalSkyWcsName=self.config.externalSkyWcsName,
                           skipTEx=self.config.skipTEx,
                           verbose=self.config.verbose,
                           metrics_package=self.config.metricsRepository,
                           instrument=self.config.instrumentName,
                           dataset_repo_url=self.config.datasetName)
        if self.config.makePlots:
            plot_metrics(job, filterName, outputPrefix=output_prefix)

    @classmethod
    def _makeArgumentParser(cls):
        parser = ArgumentParser(name=cls._DefaultName)
        parser.add_id_argument("--id", "jointcal_wcs", help="data ID, with raw CCD keys + tract",
                               ContainerClass=PerTractCcdDataIdContainer)
        return parser

    def _getMetadataName(self):
        return None
